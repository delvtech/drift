---
title: Core Concepts
---

# Core Concepts

This section explains the fundamental concepts and architecture that make Drift a powerful tool for Ethereum development.

## What Makes Drift Different?

Drift is not just another web3 library. It's a **meta-library** that provides a consistent, high-level API on top of existing libraries like ethers, viem, and web3.js. This approach offers several key advantages:

### Comparison with Direct Web3 Usage

**Without Drift:**
```ts
// Different libraries, different APIs
import { ethers } from "ethers";
import { createPublicClient } from "viem";

// Manual caching and state management required
const provider = new ethers.JsonRpcProvider(rpcUrl);
const contract = new ethers.Contract(address, abi, provider);

// No automatic caching - repeated calls hit the network
const balance1 = await contract.balanceOf(account);
const balance2 = await contract.balanceOf(account); // Redundant network call!

// Complex testing setup
// Manual mock providers and complex stubbing
```

**With Drift:**
```ts
import { createDrift } from "@delvtech/drift";

const drift = createDrift({ rpcUrl }); // Works with any web3 library
const contract = drift.contract({ abi, address });

// Automatic caching - no redundant calls
const balance1 = await contract.read("balanceOf", { account });
const balance2 = await contract.read("balanceOf", { account }); // Returns cached value

// Simple testing with built-in mocks
import { createMockDrift } from "@delvtech/drift/testing";
const mockDrift = createMockDrift();
```

### Key Benefits

- **üîÑ Provider Abstraction:** Switch between ethers, viem, web3.js without changing your application code
- **‚ö° Automatic Optimization:** Built-in caching and multicall reduce network requests
- **üõ°Ô∏è Type Safety:** Full TypeScript support with compile-time contract validation
- **üß™ Testing Made Easy:** Built-in mocking utilities eliminate complex test setup
- **üîå Extensibility:** Hooks and custom adapters for advanced use cases

## Architecture Overview

Drift's modular architecture separates concerns for maximum flexibility:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Contract   ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   Client    ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ    Hooks    ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ    Store    ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   Adapter   ‚îÇ
‚îÇ             ‚îÇ    ‚îÇ  (Drift)    ‚îÇ    ‚îÇ             ‚îÇ    ‚îÇ   (Cache)   ‚îÇ    ‚îÇ (Provider)  ‚îÇ
‚îÇ Type-safe   ‚îÇ    ‚îÇ Orchestrates‚îÇ    ‚îÇ Middleware  ‚îÇ    ‚îÇ Data Cache  ‚îÇ    ‚îÇ Web3 Bridge ‚îÇ
‚îÇ Interface   ‚îÇ    ‚îÇ Operations  ‚îÇ    ‚îÇ & Plugins   ‚îÇ    ‚îÇ & State     ‚îÇ    ‚îÇ Abstraction ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### The Drift Client

The Drift Client (`createDrift()`) is the orchestrator that coordinates all operations:

```ts
const drift = createDrift({
  adapter: viemAdapter({ publicClient }),
  store: customStore, // Optional custom cache
});

// The client provides:
await drift.read(...)      // Contract reads with caching
await drift.write(...)     // Contract writes with transaction management  
await drift.multicall(...) // Batched calls for efficiency
await drift.getEvents(...) // Event queries with caching
```

**Key Responsibilities:**
- Coordinate between components
- Manage the request/response lifecycle
- Handle caching strategies
- Provide unified API across different web3 libraries

### Contracts & Type Safety

Drift generates fully type-safe contract instances from ABIs:

```ts
const vault = drift.contract({
  abi: vaultAbi,
  address: "0x...",
});

// Full TypeScript support:
// ‚úÖ Function names autocompleted
// ‚úÖ Arguments type-checked
// ‚úÖ Return types inferred
const shares: bigint = await vault.read("balanceOf", {
  account: "0x..." // ‚úÖ Parameter names autocompleted
});

// ‚ùå This would be a compile-time error:
// await vault.read("nonExistentFunction");
// await vault.read("balanceOf", { wrongParam: "0x..." });
```

**Type Safety Benefits:**
- Catch errors at compile time, not runtime
- IDE autocompletion for function names and parameters
- Refactoring safety when ABIs change
- Self-documenting code through types

### Adapters & Provider Abstraction

Adapters normalize different web3 libraries into a consistent interface:

```ts
// All of these work with the same Drift code:

// Using Viem
const drift1 = createDrift({
  adapter: viemAdapter({ publicClient })
});

// Using Ethers
const drift2 = createDrift({
  adapter: ethersAdapter({ provider })
});

// Using Web3.js
const drift3 = createDrift({
  adapter: new Web3Adapter({ provider })
});

// Using just an RPC URL (built-in adapter)
const drift4 = createDrift({
  rpcUrl: "https://..."
});
```

**Adapter Benefits:**
- **No Vendor Lock-in:** Switch providers without code changes
- **Performance Optimization:** Leverage each library's strengths
- **Gradual Migration:** Migrate between libraries incrementally
- **Library-Specific Features:** Access provider-specific optimizations

### Smart Caching with Stores

Drift's caching system automatically prevents redundant network requests:

```ts
// First call hits the network
const balance1 = await contract.read("balanceOf", { account });

// Second call returns cached value
const balance2 = await contract.read("balanceOf", { account });

// Different parameters = new network request
const otherBalance = await contract.read("balanceOf", { account: otherAccount });

// Cache operations available
contract.cache.invalidateRead("balanceOf", { account });
contract.cache.preloadRead({ fn: "symbol", value: "USDC" });
```

**Caching Features:**
- Automatic request deduplication
- Parameter-based cache keys
- Manual cache control (invalidate, preload, clear)
- Custom store implementations (localStorage, TTL, etc.)

### Hooks & Middleware

Hooks provide powerful extension points for custom logic:

```ts
// Add logging to all read operations
drift.hooks.on("before:read", ({ args }) => {
  console.log("Reading:", args[0].fn);
});

// Automatically simulate writes before sending
drift.hooks.on("before:write", async ({ args, resolve }) => {
  const simulation = await drift.simulateWrite(args[0]);
  console.log("Simulation result:", simulation);
});

// Transform call results
drift.hooks.on("after:call", ({ result, setResult }) => {
  const transformed = processCallResult(result);
  setResult(transformed);
});
```

**Hook Capabilities:**
- Intercept any client method
- Modify arguments before execution
- Transform results after execution
- Add custom logging, monitoring, or validation
- Implement middleware patterns

## When to Use Drift vs. Direct Web3 Libraries

### Choose Drift When:

‚úÖ **Building Production dApps**
- Complex contract interactions
- Multiple contracts and chains
- Performance optimization needed
- Team collaboration and maintenance

‚úÖ **Developer Experience Matters**
- Type safety is important
- Testing is a priority
- Code reusability across projects
- Future-proofing against library changes

‚úÖ **Advanced Features Required**
- Automatic caching and optimization
- Batch operations (multicall)
- Complex state management
- Custom middleware or plugins

### Use Direct Libraries When:

‚ùå **Simple Scripts or Prototypes**
- One-off scripts or simple interactions
- Learning web3 development
- Library-specific features needed
- Minimal dependencies preferred

### Migration Strategy

You can adopt Drift incrementally:

1. **Start Small:** Use Drift for new contracts while keeping existing code
2. **Gradual Migration:** Move contracts to Drift one at a time
3. **Adapter Bridge:** Use Drift adapters to work with existing providers
4. **Full Integration:** Eventually migrate entire application to Drift

## Next Steps

Now that you understand Drift's core concepts:

- [**Reading Data**](/guides/reading-data) - Learn advanced reading patterns
- [**Caching Deep Dive**](/advanced/caching) - Master Drift's caching system
- [**Extending Drift**](/advanced/extending-drift) - Build custom adapters and stores
- [**Testing Strategies**](/guides/testing-strategies) - Test with confidence using mocks
