---
title: Caching
---

# Caching Deep Dive

Drift's intelligent caching system is a core feature that automatically
minimizes RPC calls and dramatically improves application performance. This
guide explores the caching mechanism in detail and shows you how to leverage it
effectively.

## How Caching Works

Drift automatically caches the results of `read`, `getEvents`, and other network
operations. When you make a call with the same parameters, Drift returns the
cached result instead of making another network request.

### Basic Caching Behavior

```ts
// First call: hits the network, result is cached
const balance1 = await token.read("balanceOf", { account: userAddress });

// Second call: returns cached value instantly (no network request)
const balance2 = await token.read("balanceOf", { account: userAddress });

// Different parameters: triggers new network request
const otherBalance = await token.read("balanceOf", { account: otherAddress });

// Different options: triggers new network request
const historicalBalance = await token.read(
  "balanceOf",
  { account: userAddress },
  { block: 18_000_000n },
);
```

### Cache Key Generation

Drift generates cache keys based on:

- Contract address
- Function name
- Function arguments
- Call options (block number, etc.)

```ts
// These calls have different cache keys:
await token.read("balanceOf", { account: "0x123" });
await token.read("balanceOf", { account: "0x456" });
await token.read("balanceOf", { account: "0x123" }, { block: 100n });
```

### Multicall and Caching

Multicall operations leverage individual call caching, by reducing the number of
calls made in the batch:

```ts
// These individual calls are cached
await token.read("name");
await token.read("symbol");
await token.read("decimals");

// Later multicall uses cached values when possible
const [name, symbol, decimals, totalSupply] = await token.multicall({
  allowFailure: false,
  calls: [
    { fn: "name" },        // ✅ Uses cache
    { fn: "symbol" },      // ✅ Uses cache
    { fn: "decimals" },    // ✅ Uses cache
    { fn: "totalSupply" }, // ❌ New network request
  ],
});
```

## Cache Invalidation

When contract state changes (through transactions), you need to invalidate
affected cache entries to prevent stale data.

### Manual Invalidation

```ts
// Invalidate specific cache entry
token.cache.invalidateRead("balanceOf", { account: userAddress });

// Invalidate all calls to a function (any arguments)
token.cache.invalidateReadsMatching("balanceOf");

// Invalidate multiple specific calls
token.cache.invalidateRead("totalSupply");
token.cache.invalidateRead("balanceOf", { account: senderAddress });
token.cache.invalidateRead("balanceOf", { account: receiverAddress });
```

### Automatic Invalidation with `onMined`

The most common pattern is to invalidate cache in transaction callbacks:

```ts
await token.write(
  "transfer",
  { to: recipientAddress, amount: BigInt(100e18) },
  {
    onMined: (receipt) => {
      if (receipt?.status === "success") {
        // Invalidate affected balances
        token.cache.invalidateRead("balanceOf", { account: senderAddress });
        token.cache.invalidateRead("balanceOf", { account: recipientAddress });

        // Optionally invalidate total supply if it could be affected
        token.cache.invalidateRead("totalSupply");
      }
    },
  },
);
```

### Event-Based Invalidation

You can also invalidate cache based on events:

```ts
// Watch for Transfer events and invalidate affected balances
const transferEvents = await token.getEvents("Transfer", {
  fromBlock: currentBlock,
  toBlock: "latest",
});

transferEvents.forEach((event) => {
  const { from, to } = event.args;
  token.cache.invalidateRead("balanceOf", { account: from });
  token.cache.invalidateRead("balanceOf", { account: to });
});
```

## Cache Clearing

### Selective Clearing

```ts
// Clear all reads for a specific contract
token.cache.clearReads();

// Clear all events for a specific contract
token.cache.clearEvents();

// Clear everything for a specific contract
token.cache.clear();

// Clear specific data types across all contracts
drift.cache.clearReads();    // All read calls
drift.cache.clearEvents();   // All events
drift.cache.clearBalances(); // All balance queries
drift.cache.clearBlocks();   // All block data
```

### Complete Cache Reset

```ts
// Clear everything in the cache
drift.cache.clear();
```

## Preloading Data

Preloading allows you to populate the cache with known values, avoiding network
requests entirely.

### Preloading Reads

```ts
// Preload static token data
token.cache.preloadRead({ fn: "name", value: "USD Coin" });
token.cache.preloadRead({ fn: "symbol", value: "USDC" });
token.cache.preloadRead({ fn: "decimals", value: 6 });

// These calls now return instantly without network requests
const name = await token.read("name");
const symbol = await token.read("symbol");
const decimals = await token.read("decimals");
```

### Preloading from External Sources

```ts
// Preload data from token lists or APIs
const tokenList = await fetch("https://tokens.coingecko.com/uniswap/all.json");

tokenList.tokens.forEach((tokenData) => {
  const tokenContract = drift.contract({
    abi: erc20.abi,
    address: tokenData.address,
  });

  tokenContract.cache.preloadRead({ fn: "name", value: tokenData.name });
  tokenContract.cache.preloadRead({ fn: "symbol", value: tokenData.symbol });
  tokenContract.cache.preloadRead({
    fn: "decimals",
    value: tokenData.decimals,
  });
});
```

### Preloading Events

```ts
// Preload empty events to avoid unnecessary queries
token.cache.preloadEvents({
  event: "Transfer",
  value: [], // Empty array indicates no events in this range
  fromBlock: 18_000_000n,
  toBlock: 18_100_000n,
});

// This query will return immediately with empty array
const events = await token.getEvents("Transfer", {
  fromBlock: 18_000_000n,
  toBlock: 18_100_000n,
});
```

## Direct Cache Access

For advanced use cases, you can directly interact with the cache.

### Reading from Cache

```ts
// Check if a value is cached without triggering a network request
const cachedBalance = await token.cache.getRead("balanceOf", {
  account: userAddress,
});

if (cachedBalance !== undefined) {
  console.log("Balance is cached:", cachedBalance);
} else {
  console.log("Balance not in cache, would trigger network request");
}

// Get cached events
const cachedEvents = await token.cache.getEvents("Transfer", {
  fromBlock: 18_000_000n,
  toBlock: 18_100_000n,
});
```

### Writing to Cache

```ts
// Directly set cache values
await token.cache.setRead(
  { fn: "balanceOf", args: { account: userAddress } },
  BigInt(1000e18),
);

// Set multiple values
await Promise.all([
  token.cache.setRead({ fn: "name" }, "My Token"),
  token.cache.setRead({ fn: "symbol" }, "MTK"),
  token.cache.setRead({ fn: "decimals" }, 18),
]);
```

## Cache Sharing and Isolation

### Shared Cache Across Contracts

All Drift contracts share the same cache instance by default:

```ts
const drift = createDrift({ rpcUrl: "..." });

const tokenA = drift.contract({ abi: erc20.abi, address: addressA });
const tokenB = drift.contract({ abi: erc20.abi, address: addressB });

// These share the same cache
tokenA.cache === tokenB.cache; // true
```

### Contract-Specific Operations

Even though the cache is shared, operations are contract-specific:

```ts
// This only invalidates reads for tokenA
tokenA.cache.clearReads();

// tokenB's cache entries are unaffected
const tokenBName = await tokenB.read("name"); // Uses cache if available
```

## Performance Optimization Patterns

### 1. Batch Cache Invalidation

```ts
// ❌ Multiple individual invalidations
token.cache.invalidateRead("balanceOf", { account: user1 });
token.cache.invalidateRead("balanceOf", { account: user2 });
token.cache.invalidateRead("balanceOf", { account: user3 });

// ✅ Batch invalidation
function invalidateUserBalances(users: Address[]) {
  users.forEach((user) => {
    token.cache.invalidateRead("balanceOf", { account: user });
  });
}

// Or clear all balance calls if many are affected
token.cache.invalidateReadsMatching("balanceOf");
```

### 2. Strategic Preloading

```ts
// Preload commonly accessed data at app startup
async function initializeTokenCache(token: Contract) {
  // Preload static data that never changes
  const [name, symbol, decimals] = await token.multicall({
    allowFailure: false,
    calls: [{ fn: "name" }, { fn: "symbol" }, { fn: "decimals" }],
  });

  // Data is now cached for future use
}
```

### 3. Cache-Aware Data Fetching

```ts
async function getUserData(userAddress: Address) {
  // Check cache first to avoid unnecessary multicall
  const cachedBalance = await token.cache.getRead("balanceOf", {
    account: userAddress,
  });

  if (cachedBalance !== undefined) {
    // Use cached data
    return {
      balance: cachedBalance,
      // ... other data
    };
  }

  // Fetch all data if balance not cached
  const [balance, allowances] = await token.multicall({
    allowFailure: false,
    calls: [
      { fn: "balanceOf", args: { account: userAddress } },
      // ... other calls
    ],
  });

  return { balance, allowances };
}
```

## Custom Store Implementation

For persistent caching or custom cache policies, implement a custom store:

```ts
import { type Store } from "@delvtech/drift";

// Example: localStorage-backed cache
class LocalStorageStore implements Store {
  private prefix = "drift-cache:";

  get(key: string): unknown {
    const item = localStorage.getItem(this.prefix + key);
    return item ? JSON.parse(item) : undefined;
  }

  set(key: string, value: unknown): void {
    localStorage.setItem(this.prefix + key, JSON.stringify(value));
  }

  delete(key: string): void {
    localStorage.removeItem(this.prefix + key);
  }

  clear(): void {
    Object.keys(localStorage)
      .filter((key) => key.startsWith(this.prefix))
      .forEach((key) => localStorage.removeItem(key));
  }

  // Implement other Store interface methods...
}

const drift = createDrift({
  rpcUrl: "...",
  store: new LocalStorageStore(),
});
```

## Cache Debugging

### Monitoring Cache Performance

```ts
// Add hooks to monitor cache hits/misses
drift.hooks.on("before:read", ({ args }) => {
  const params = args[0];
  const cached = drift.cache.getRead(params);
  console.log(cached ? "CACHE HIT" : "CACHE MISS", params.fn);
});

drift.hooks.on("after:read", ({ args, result }) => {
  console.log("Read completed:", args[0].fn, "->", result);
});
```

### Cache Inspection

```ts
// Get all cached read calls for debugging
function inspectCache(contract: Contract) {
  // Note: This would require extending the cache interface
  // to expose internal state for debugging
  console.log("Cache contents:", contract.cache.debug?.getAll());
}
```

## Best Practices

### 1. Invalidate Conservatively

```ts
// ❌ Over-invalidation hurts performance
drift.cache.clear(); // Clears everything

// ✅ Invalidate only what's affected
token.cache.invalidateRead("balanceOf", { account: affectedAddress });
```

### 2. Use Multicall for Initial Data Loading

```ts
// ❌ Sequential calls (even if cached, less efficient)
const name = await token.read("name");
const symbol = await token.read("symbol");
const decimals = await token.read("decimals");

// ✅ Batch initial loading
const [name, symbol, decimals] = await token.multicall({
  allowFailure: false,
  calls: [{ fn: "name" }, { fn: "symbol" }, { fn: "decimals" }],
});
```

### 3. Strategic Cache Warming

```ts
// Warm cache for frequently accessed data
async function warmCache() {
  await Promise.all([
    // Load token metadata
    token.multicall({
      calls: [{ fn: "name" }, { fn: "symbol" }, { fn: "totalSupply" }],
    }),

    // Load user-specific data
    token.read("balanceOf", { account: currentUser }),
  ]);
}
```

## Next Steps

- [**Reading Data**](/guides/reading-data) - Learn how reads interact with cache
- [**Writing Data**](/guides/writing-data) - Cache invalidation patterns
- [**Extending Drift**](/advanced/extending-drift) - Custom store implementations
- [**Testing**](/guides/testing-strategies) - Test cache behavior with mocks
